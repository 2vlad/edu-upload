{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Supabase Integration",
        "description": "Configure Supabase client, database schema, and authentication for course management",
        "details": "Install @supabase/supabase-js, create lib/supabaseClient.ts singleton, setup environment variables (NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY). Create database schema with tables: courses, lessons, source_files, course_assets with proper RLS policies. Implement anonymous authentication flow that checks existing session before creating new user to avoid duplicate accounts. Setup Storage buckets for course-uploads and course-assets with appropriate access policies.",
        "testStrategy": "Test anonymous auth flow, verify RLS policies restrict access to user's own data, test storage bucket uploads with proper permissions",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Supabase dependencies and setup environment variables",
            "description": "Install @supabase/supabase-js package and configure environment variables for Supabase connection",
            "dependencies": [],
            "details": "Run npm install @supabase/supabase-js. Add NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY to .env.local file (create from .env.example template). Update .env.example to include the new Supabase environment variables for future reference.",
            "status": "done",
            "testStrategy": "Verify package installation in package.json and test environment variable loading"
          },
          {
            "id": 2,
            "title": "Create Supabase client singleton",
            "description": "Create lib/supabaseClient.ts with configured Supabase client instance",
            "dependencies": [
              "1.1"
            ],
            "details": "Create lib/supabaseClient.ts file exporting a singleton Supabase client instance using createClient from @supabase/supabase-js. Configure with environment variables NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY. Include proper TypeScript types and error handling for missing environment variables.",
            "status": "done",
            "testStrategy": "Test client creation and basic connection to Supabase project"
          },
          {
            "id": 3,
            "title": "Design and create database schema",
            "description": "Create SQL schema for courses, lessons, source_files, and course_assets tables with proper relationships",
            "dependencies": [
              "1.2"
            ],
            "details": "Design database schema with tables: courses (id, title, description, status, user_id, slug, created_at, updated_at), lessons (id, course_id, title, content, objectives, order_index), source_files (id, course_id, filename, file_path, uploaded_at), course_assets (id, course_id, asset_type, asset_path, created_at). Create foreign key relationships and indexes for performance.",
            "status": "done",
            "testStrategy": "Validate schema creation and test table relationships"
          },
          {
            "id": 4,
            "title": "Implement Row Level Security policies",
            "description": "Setup RLS policies to ensure users can only access their own course data",
            "dependencies": [
              "1.3"
            ],
            "details": "Enable RLS on all tables. Create policies that allow users to insert, select, update, and delete only their own records based on user_id or auth.uid(). Set up policies for anonymous users to access published courses (read-only). Test policies ensure proper data isolation between users.",
            "status": "done",
            "testStrategy": "Test RLS policies with different user scenarios and verify data access restrictions"
          },
          {
            "id": 5,
            "title": "Setup anonymous authentication and Storage buckets",
            "description": "Implement anonymous authentication flow and create Storage buckets with access policies",
            "dependencies": [
              "1.4"
            ],
            "details": "Implement anonymous authentication that checks for existing session before creating new users to prevent duplicates. Create Storage buckets: 'course-uploads' for PDF files and 'course-assets' for generated content. Configure bucket policies to allow authenticated users to upload/access their own files. Set up proper file organization with user-specific folders.",
            "status": "done",
            "testStrategy": "Test anonymous auth flow prevents duplicate accounts, verify storage upload permissions and file access"
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Multi-Format File Parser",
        "description": "Create document parsers for DOCX, MD, TXT, RTF, HTML formats and image handling",
        "details": "Install mammoth for DOCX parsing, striprtf for RTF, jsdom for HTML processing. Create lib/parsers/ directory with individual parser modules (pdf.ts, docx.ts, rtf.ts, md.ts, html.ts). Implement image handling for PNG/JPG/WebP upload to Supabase Storage. Create unified ExtractedFile interface with id, filename, mime, text, imagePath fields. Add file validation, size limits (20-30MB), and error handling for corrupted files.",
        "testStrategy": "Test each parser with sample files, verify text extraction quality, test image upload to storage, validate file size and type restrictions",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install required dependencies for multi-format parsing",
            "description": "Install mammoth for DOCX parsing, striprtf for RTF parsing, jsdom for HTML processing, and any additional dependencies needed for MD and TXT parsing",
            "dependencies": [],
            "details": "Run npm install commands for mammoth, striprtf, jsdom packages. Update package.json with new dependencies. Verify installations work correctly with basic import tests. These libraries will provide the core parsing functionality for different document formats.",
            "status": "done",
            "testStrategy": "Verify each package can be imported successfully and basic functionality works with simple test documents"
          },
          {
            "id": 2,
            "title": "Create lib/parsers directory and unified ExtractedFile interface",
            "description": "Set up the parser directory structure and define the common interface that all parsers will return",
            "dependencies": [],
            "details": "Create lib/parsers/ directory structure. Define ExtractedFile interface with id, filename, mime, text, and imagePath fields in a types.ts file. This interface will standardize the output from all different parsers and ensure consistency across the application.",
            "status": "done",
            "testStrategy": "Verify directory structure is created correctly and interface can be imported in other files"
          },
          {
            "id": 3,
            "title": "Implement individual parser modules for each format",
            "description": "Create separate parser files for PDF, DOCX, RTF, MD, TXT, and HTML formats that all return the ExtractedFile interface",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Create pdf.ts (refactor existing logic), docx.ts (using mammoth), rtf.ts (using striprtf), md.ts (plain text parsing), txt.ts (direct reading), and html.ts (using jsdom) in lib/parsers/. Each parser should handle file validation, text extraction, and return standardized ExtractedFile format. Include proper error handling for corrupted or invalid files.",
            "status": "done",
            "testStrategy": "Test each parser with sample files of respective formats, verify text extraction quality and error handling for corrupted files"
          },
          {
            "id": 4,
            "title": "Implement image handling and Supabase Storage integration",
            "description": "Add support for PNG/JPG/WebP image uploads to Supabase Storage with proper path management",
            "dependencies": [
              "2.2"
            ],
            "details": "Create image parser module that handles PNG/JPG/WebP formats. Implement Supabase Storage client for uploading images with proper bucket configuration and path generation. Add image metadata extraction and ensure imagePath field is populated in ExtractedFile interface. Handle image compression and optimization if needed.",
            "status": "done",
            "testStrategy": "Test image upload to Supabase Storage, verify proper paths are generated, test with different image formats and sizes"
          },
          {
            "id": 5,
            "title": "Add file validation, size limits and error handling",
            "description": "Implement comprehensive file validation including MIME type checking, size limits (20-30MB), and robust error handling for all supported formats",
            "dependencies": [
              "2.3",
              "2.4"
            ],
            "details": "Create validation utility functions for MIME type detection, file size checking (20-30MB limit), and format-specific validation. Implement comprehensive error handling with user-friendly error messages for unsupported formats, oversized files, and corrupted documents. Add logging for debugging parsing issues. Ensure all parsers use consistent validation and error handling patterns.",
            "status": "done",
            "testStrategy": "Test file size limits with large files, verify MIME type detection works correctly, test error handling with corrupted and unsupported files"
          }
        ]
      },
      {
        "id": 3,
        "title": "Refactor API Endpoint for Multi-Format Processing",
        "description": "Replace /api/process-pdfs with /api/process-files supporting all document types",
        "details": "Create new app/api/process-files/route.ts endpoint replacing process-pdfs. Implement MIME type detection and routing to appropriate parsers. Update FormData handling for mixed file types including images. Maintain backward compatibility by creating redirect from old endpoint. Add text normalization, chunking for large documents (2-5k tokens), and combined text aggregation.",
        "testStrategy": "Test with various file combinations, verify proper MIME detection, test large file handling, validate API response format matches expected schema",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create new /api/process-files endpoint structure",
            "description": "Create the new app/api/process-files/route.ts file with proper TypeScript structure and imports. Set up the basic endpoint handler with error handling and API key validation.",
            "dependencies": [],
            "details": "Create app/api/process-files/route.ts file. Import necessary modules: NextRequest, NextResponse from next/server, generateObject from ai, createOpenAI from @ai-sdk/openai, and zod for schema validation. Set up OpenAI client configuration using process.env.OPENAI_API_KEY. Implement basic POST function structure with try-catch error handling and API key validation similar to existing process-pdfs endpoint.",
            "status": "done",
            "testStrategy": "Test endpoint creation and basic error handling, verify API key validation works correctly"
          },
          {
            "id": 2,
            "title": "Implement MIME type detection and file validation",
            "description": "Add comprehensive MIME type detection for all supported file formats (PDF, DOCX, MD, TXT, RTF, HTML, PNG, JPG, WebP) with proper file validation and size limits.",
            "dependencies": [
              "3.1"
            ],
            "details": "Create a MIME type detection function that identifies file types based on both file.type property and file extensions. Implement file validation with size limits (20-30MB as specified in task dependencies). Create constants for supported MIME types: application/pdf, application/vnd.openxmlformats-officedocument.wordprocessingml.document, text/markdown, text/plain, application/rtf, text/html, image/png, image/jpeg, image/webp. Add file filtering and validation logic in the FormData processing section.",
            "status": "done",
            "testStrategy": "Test MIME type detection accuracy with various file formats, verify size limit enforcement, test rejection of unsupported file types"
          },
          {
            "id": 3,
            "title": "Implement file routing to appropriate parsers",
            "description": "Create router logic that directs different file types to their respective parser functions, integrating with the lib/parsers/ modules from task 2.",
            "dependencies": [
              "3.2"
            ],
            "details": "Import parser functions from lib/parsers/ directory (pdf.ts, docx.ts, rtf.ts, md.ts, html.ts modules). Create a routing function that takes a file and its MIME type and calls the appropriate parser. Handle image files separately by uploading to storage and storing the path. Implement Promise.all for parallel processing of multiple files. Create aggregation logic for combining extracted text from multiple documents while maintaining file source information.",
            "status": "done",
            "testStrategy": "Test routing logic with mixed file types, verify parser integration works correctly, test parallel processing performance"
          },
          {
            "id": 4,
            "title": "Add text normalization and chunking for large documents",
            "description": "Implement text processing features including normalization, chunking for large documents (2-5k tokens), and intelligent text aggregation for better AI processing.",
            "dependencies": [
              "3.3"
            ],
            "details": "Create text normalization function to clean extracted text (remove extra whitespace, fix encoding issues, standardize line breaks). Implement chunking logic for documents exceeding 2000-5000 tokens using simple token estimation (word count * 1.3). Create intelligent text aggregation that preserves document structure while combining content from multiple files. Add document separator markers between different source files. Ensure the combined text maintains readability and context for OpenAI processing.",
            "status": "done",
            "testStrategy": "Test text normalization with various character encodings, verify chunking works with large documents, test aggregation maintains document context"
          },
          {
            "id": 5,
            "title": "Update OpenAI schema and add backward compatibility redirect",
            "description": "Update the generateObject schema to handle multi-format content and create redirect logic from old /api/process-pdfs endpoint to maintain backward compatibility.",
            "dependencies": [
              "3.4"
            ],
            "details": "Update the OpenAI prompt and schema in generateObject to handle content from multiple file formats, not just PDFs. Modify the prompt text to refer to 'documents' instead of 'PDF documents'. Update the response schema to include source file information if needed. Create a redirect handler in the original app/api/process-pdfs/route.ts that redirects requests to the new /api/process-files endpoint while maintaining the same request/response format. Test that the existing upload page continues to work without modification during transition period.",
            "status": "done",
            "testStrategy": "Test schema handles multi-format content correctly, verify backward compatibility redirect works, test that existing frontend continues to function properly"
          }
        ]
      },
      {
        "id": 4,
        "title": "Extend Zod Schema with Guidance Fields",
        "description": "Update OpenAI generateObject schema to include guidance questions, tips, and outline bullets",
        "details": "Extend existing Zod schema to include outline array with lesson_id, title, logline, bullets fields. Add guidance fields to lessons: guiding_questions (5-8 items), expansion_tips (3-6 items), examples_to_add (2-5 items). Update OpenAI prompt to generate guidance content in Russian. Ensure schema maintains backward compatibility with existing course data structure.",
        "testStrategy": "Validate schema against sample data, test OpenAI generation produces expected guidance fields, verify Russian language output quality",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define extended lesson schema with guidance fields",
            "description": "Add new Zod schema fields to the lesson object for guidance questions, tips, and examples in Russian",
            "dependencies": [],
            "details": "Extend the existing lesson schema in app/api/process-pdfs/route.ts to include: guiding_questions as z.array(z.string()).min(5).max(8).describe('Направляющие вопросы на русском языке'), expansion_tips as z.array(z.string()).min(3).max(6).describe('Советы по расширению на русском языке'), examples_to_add as z.array(z.string()).min(2).max(5).describe('Примеры для добавления на русском языке'). Maintain backward compatibility with existing lesson structure.",
            "status": "done",
            "testStrategy": "Validate schema accepts new fields with correct array lengths, test backward compatibility with existing lesson data"
          },
          {
            "id": 2,
            "title": "Add course outline schema structure",
            "description": "Create new Zod schema for course outline with lesson_id, title, logline, and bullets fields",
            "dependencies": [],
            "details": "Add outline array to the main course schema: outline: z.array(z.object({ lesson_id: z.string().describe('Идентификатор урока'), title: z.string().describe('Заголовок урока на русском языке'), logline: z.string().describe('Краткое описание урока на русском языке'), bullets: z.array(z.string()).min(3).max(5).describe('Ключевые пункты урока на русском языке') })). This should be a separate field from lessons array to provide a condensed overview.",
            "status": "done",
            "testStrategy": "Verify outline structure matches lesson count, validate bullet point constraints, test Russian language descriptions"
          },
          {
            "id": 3,
            "title": "Update OpenAI prompt for guidance content generation",
            "description": "Modify the OpenAI prompt to instruct generation of guidance fields in Russian language",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Update the prompt in app/api/process-pdfs/route.ts to include instructions for generating guidance content. Add specific sections requesting: 5-8 направляющих вопросов для каждого урока, 3-6 советов по расширению материала, 2-5 практических примеров для добавления. Emphasize that all guidance content should be in Russian and contextually relevant to the lesson content extracted from the PDFs.",
            "status": "done",
            "testStrategy": "Test prompt generates guidance fields within specified ranges, verify Russian language output quality, check contextual relevance to lesson content"
          },
          {
            "id": 4,
            "title": "Implement schema validation and error handling",
            "description": "Add comprehensive validation for new schema fields with proper error messages",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Implement validation middleware to ensure: guidance arrays meet min/max constraints, Russian language content is properly encoded, outline lesson_ids match actual lesson ids, backward compatibility with existing course data structures. Add specific error messages in Russian for validation failures. Include fallback handling if OpenAI doesn't generate guidance fields - provide empty arrays rather than failing.",
            "status": "done",
            "testStrategy": "Test validation catches constraint violations, verify error messages are in Russian, test backward compatibility with old course data, validate fallback behavior"
          },
          {
            "id": 5,
            "title": "Update TypeScript interfaces for new schema fields",
            "description": "Extend TypeScript interfaces in course and lesson pages to include new guidance and outline fields",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Update the Lesson interface in app/course/page.tsx and any other relevant files to include: guiding_questions?: string[], expansion_tips?: string[], examples_to_add?: string[]. Add new CourseOutline interface with lesson_id, title, logline, bullets fields. Update CourseData interface to include outline?: CourseOutline[]. Make all new fields optional to maintain backward compatibility with existing localStorage data.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds, test existing course pages work with extended interfaces, validate optional field handling in UI components"
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Course Outline Page",
        "description": "Build new /outline page showing vertical list of lessons with bullets and editing capabilities",
        "details": "Create app/outline/page.tsx with vertical lesson list displaying title, logline, and 3-5 bullet points per lesson. Implement inline editing for course title/description. Add source file management with 'Edit sources', 'Add files', and 'Update outline' buttons. Include drag-and-drop reordering of lessons. Redirect from upload page to outline instead of lessons. Style with consistent UI patterns matching existing design.",
        "testStrategy": "Test outline display with generated course data, verify drag-and-drop reordering, test inline editing functionality, validate source file management",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create outline page component structure",
            "description": "Create the main outline page component with vertical layout for course outline display",
            "dependencies": [],
            "details": "Create app/outline/page.tsx with the basic component structure. Use the existing CourseData and Lesson interfaces from the lessons page. Set up state management for course data loaded from localStorage ('courseData' key). Include header section with course title/description and back navigation to lessons. Follow the existing design patterns with rounded buttons (50px border radius for primary buttons), proper typography, and consistent spacing from other pages.",
            "status": "done",
            "testStrategy": "Test that the page renders correctly, loads course data from localStorage, displays proper header navigation, and follows consistent styling patterns"
          },
          {
            "id": 2,
            "title": "Implement vertical lesson list with bullets",
            "description": "Build the main lesson list displaying title, logline, and 3-5 bullet points per lesson in vertical layout",
            "dependencies": [
              "5.1"
            ],
            "details": "Create a vertical list of lesson cards that displays lesson title prominently, extract logline from lesson content (first paragraph or summary), and show 3-5 key bullet points from lesson objectives. Use Card components consistent with existing pages. Each lesson card should be full-width with proper spacing between lessons. Include lesson numbers/ordering indicators. Handle truncation for long content with proper ellipsis. Style bullets with consistent formatting and spacing.",
            "status": "done",
            "testStrategy": "Verify lesson data renders correctly, bullet points are properly formatted, content truncation works, and list scrolls properly with many lessons"
          },
          {
            "id": 3,
            "title": "Add inline editing for course title and description",
            "description": "Implement inline editing functionality for course title and description in the header section",
            "dependencies": [
              "5.1"
            ],
            "details": "Add edit/save toggle buttons for course title and description in the header. Use Input and Textarea components from the UI library. Implement edit state management similar to the lesson editing in lessons/page.tsx. Include save/cancel functionality that updates localStorage ('courseData' key). Use the existing edit icons (Edit2, Save, X) and button styling patterns. Ensure proper validation and error handling for empty titles.",
            "status": "done",
            "testStrategy": "Test inline editing toggle, data persistence to localStorage, cancel functionality resets changes, and validation prevents empty titles"
          },
          {
            "id": 4,
            "title": "Implement source file management buttons",
            "description": "Add 'Edit sources', 'Add files', and 'Update outline' buttons with proper styling and initial functionality",
            "dependencies": [
              "5.1"
            ],
            "details": "Create three action buttons in the header or top section: 'Edit sources' (outline variant), 'Add files' (outline variant), 'Update outline' (primary variant with rounded-[30px] styling). Use existing UI patterns and icon choices (FileText, Upload, RefreshCw or similar). Initially implement button click handlers that show placeholder functionality or console logs. Position buttons appropriately in the header section alongside the course title/description area. Ensure responsive layout on smaller screens.",
            "status": "done",
            "testStrategy": "Verify buttons render with correct styling, click handlers work, responsive layout maintains usability, and buttons follow design system patterns"
          },
          {
            "id": 5,
            "title": "Add drag-and-drop lesson reordering and redirect logic",
            "description": "Implement drag-and-drop reordering of lessons and update upload page to redirect to outline instead of lessons",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Implement drag-and-drop functionality using the same pattern as lessons/page.tsx with handleDragStart, handleDragOver, handleDrop, and handleDragEnd functions. Update lesson order in courseData state and persist to localStorage. Add visual feedback during dragging (cursor styles, drag indicators). Modify app/page.tsx to redirect to '/outline' instead of '/lessons' after PDF processing completes (line 112: router.push('/outline')). Ensure lesson reordering works smoothly and updates the vertical list immediately.",
            "status": "done",
            "testStrategy": "Test drag-and-drop reordering updates lesson order correctly, changes persist in localStorage, visual feedback works during drag operations, and upload page redirects to outline page after processing"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Non-Destructive Course Updates",
        "description": "Add capability to update course outline without losing manually edited content",
        "details": "Implement intelligent merge logic that preserves existing lesson IDs and manually edited content while adding new lessons and updating guidance fields. Create diff preview showing proposed changes before applying. Add prompt engineering to instruct AI to maintain existing structure. Store edit timestamps to track manual vs AI-generated content. Implement conflict resolution for overlapping changes.",
        "testStrategy": "Test update workflow preserves edited content, verify new lessons are added correctly, test diff preview accuracy, validate no data loss during updates",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create course versioning and edit tracking system",
            "description": "Implement metadata tracking to distinguish between AI-generated and manually edited content with timestamps",
            "dependencies": [],
            "details": "Extend the CourseData interface to include version metadata, edit timestamps, and source tracking (ai-generated vs manual). Add lastModified, editHistory, and isManuallyEdited fields to lessons. Create utility functions to track edit sources and timestamps. Store this metadata in localStorage alongside course data to preserve manual edit information across sessions.",
            "status": "done",
            "testStrategy": "Test metadata tracking during lesson edits, verify timestamps are recorded correctly, validate manual vs AI-generated content distinction"
          },
          {
            "id": 2,
            "title": "Implement intelligent merge logic for course updates",
            "description": "Create merge algorithms that preserve existing lesson IDs and manually edited content while integrating new lessons",
            "dependencies": [
              "6.1"
            ],
            "details": "Create lib/courseUpdates.ts with merge functions that: 1) Match existing lessons by ID and preserve manual edits, 2) Add new lessons from updated content while maintaining existing lesson order, 3) Update only AI-generated guidance fields (objectives, tips) while preserving manual content edits, 4) Handle lesson reordering and ID conflicts intelligently, 5) Implement conflict resolution strategies for overlapping changes.",
            "status": "done",
            "testStrategy": "Test merge logic with various scenarios: new lessons added, existing lessons preserved, manual edits maintained, guidance fields updated appropriately"
          },
          {
            "id": 3,
            "title": "Create diff preview system for proposed changes",
            "description": "Build UI component to show before/after comparison of course updates before applying changes",
            "dependencies": [
              "6.2"
            ],
            "details": "Create components/CourseUpdatePreview.tsx with diff visualization showing: 1) New lessons to be added, 2) Existing lessons that will be preserved, 3) Guidance fields that will be updated, 4) Manual edits that will be protected, 5) Side-by-side comparison view with approve/reject options for individual changes. Use color coding to distinguish between different types of changes (additions, updates, preserved content).",
            "status": "done",
            "testStrategy": "Test diff preview accuracy against actual merge results, verify all change types are clearly displayed, test user interaction with approve/reject options"
          },
          {
            "id": 4,
            "title": "Enhance OpenAI prompt engineering for structure preservation",
            "description": "Update AI prompts to instruct GPT to maintain existing course structure and lesson IDs when generating updates",
            "dependencies": [
              "6.1"
            ],
            "details": "Modify app/api/process-pdfs/route.ts to accept existing course data and instruct OpenAI to: 1) Preserve existing lesson IDs and manually edited content, 2) Generate new lessons with incremental IDs, 3) Focus updates on guidance fields (objectives, tips, examples), 4) Maintain logical lesson sequence, 5) Include existing course context in prompt to ensure coherent updates. Add request parameter to differentiate between new course creation and course updates.",
            "status": "done",
            "testStrategy": "Test AI responses maintain existing structure, verify new content integrates logically, validate lesson ID preservation and incremental assignment"
          },
          {
            "id": 5,
            "title": "Integrate update workflow in lessons page",
            "description": "Add course update functionality to the lessons page with diff preview and merge application",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Add 'Update Course' button to lessons page header alongside 'Publish Course'. Implement file upload modal for additional documents. Connect to enhanced API endpoint for course updates. Display CourseUpdatePreview component for user review. Apply approved changes using merge logic while preserving localStorage data integrity. Add rollback functionality in case of errors. Show success/error notifications for update operations.",
            "status": "done",
            "testStrategy": "Test complete update workflow from file upload to merge application, verify no data loss during updates, test rollback functionality, validate user experience flow"
          }
        ]
      },
      {
        "id": 7,
        "title": "Redesign Lessons Page with Guidance Features",
        "description": "Transform lessons page to vertical TOC layout with guidance panel and enhanced editing",
        "details": "Replace horizontal carousel with left sidebar TOC and right-side lesson editor. Add Guidance section displaying guiding_questions, expansion_tips, examples_to_add with 'Insert as outline' and 'Regenerate' buttons. Implement image attachment from Storage with drag-and-drop insertion into markdown content. Add toggle between Outline and Cards view for backward compatibility. Update lesson editing to support all new fields.",
        "testStrategy": "Test TOC navigation, verify guidance features work correctly, test image insertion workflow, validate toggle between view modes",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TOC Sidebar Component with Navigation",
            "description": "Replace horizontal carousel with left sidebar displaying table of contents with clickable lesson navigation",
            "dependencies": [],
            "details": "Create a new sidebar component using the existing SidebarProvider from @/components/ui/sidebar. Replace the horizontal carousel (scrollContainerRef, scroll buttons) with a vertical TOC sidebar showing lesson titles as clickable navigation items. Implement active lesson highlighting and smooth selection transition. Use existing Card styling patterns and maintain drag-and-drop reordering functionality in the sidebar. Update layout to be flex with sidebar on left and content area on right.",
            "status": "done",
            "testStrategy": "Test TOC navigation between lessons, verify active lesson highlighting, test drag-and-drop reordering in sidebar format"
          },
          {
            "id": 2,
            "title": "Implement Guidance Panel with Display Features",
            "description": "Add guidance section displaying guiding_questions, expansion_tips, examples_to_add fields with proper UI layout",
            "dependencies": [
              "7.1"
            ],
            "details": "Create guidance panel component that displays the new lesson fields (guiding_questions, expansion_tips, examples_to_add) from the enhanced Lesson interface. Position the guidance panel in the lesson editor area, possibly as a collapsible section or secondary panel. Use existing UI components like Card, proper typography, and list formatting. Display arrays as bulleted lists with clear section headers. Ensure responsive design that works with the new sidebar layout.",
            "status": "done",
            "testStrategy": "Test guidance content display for all field types, verify responsive layout with sidebar, test collapsible functionality if implemented"
          },
          {
            "id": 3,
            "title": "Add Insert as Outline and Regenerate Buttons",
            "description": "Implement action buttons for guidance features with 'Insert as outline' and 'Regenerate' functionality",
            "dependencies": [
              "7.2"
            ],
            "details": "Add two action buttons to each guidance section: 'Insert as outline' (inserts selected guidance items as markdown outline into lesson content) and 'Regenerate' (calls API to regenerate specific guidance section). Use existing Button component with appropriate styling (rounded-[30px] for primary actions). Implement modal confirmation for regenerate actions. Create utility functions to format guidance items as markdown outline. Handle button states (loading, disabled) during API calls.",
            "status": "done",
            "testStrategy": "Test outline insertion into markdown content, verify regenerate API calls, test button states and loading indicators"
          },
          {
            "id": 4,
            "title": "Implement Image Attachment with Drag-and-Drop",
            "description": "Add image upload functionality with drag-and-drop insertion into markdown content editor",
            "dependencies": [
              "7.2"
            ],
            "details": "Create image upload component that supports drag-and-drop from local files. Implement file handling for image types (PNG, JPG, WebP). Add upload functionality to Supabase Storage (when available) or temporary local storage. Create markdown insertion functionality that adds image references at cursor position in the Textarea editor. Add image preview and management UI. Use existing drag-and-drop patterns from the current lesson reordering implementation as reference.",
            "status": "done",
            "testStrategy": "Test drag-and-drop image upload, verify markdown insertion at correct cursor position, test image preview functionality"
          },
          {
            "id": 5,
            "title": "Add View Toggle Between Outline and Cards Mode",
            "description": "Implement toggle switch to switch between new vertical TOC layout and original horizontal cards view for backward compatibility",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Add toggle component (using existing Toggle from @/components/ui/toggle) in the header section to switch between 'Outline' (new vertical TOC) and 'Cards' (original horizontal carousel) view modes. Preserve view preference in localStorage. Conditionally render either the new sidebar layout or original carousel based on toggle state. Ensure all functionality (editing, drag-and-drop, lesson navigation) works in both modes. Update lesson editing modal to support new guidance fields regardless of view mode.",
            "status": "done",
            "testStrategy": "Test toggle between view modes, verify localStorage persistence of preference, test all features work in both modes"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Course Publishing System",
        "description": "Create publish functionality that saves courses to Supabase with proper data relationships",
        "details": "Create server action for publishing courses to Supabase tables. Implement auto-authentication for anonymous users if not logged in. Handle file uploads to Storage buckets with proper paths. Generate unique course slugs and update course status to published. Create upsert logic for both new and updated courses. Implement proper error handling and rollback for failed publishes.",
        "testStrategy": "Test complete publish flow from draft to published, verify all data saved correctly, test anonymous auth during publish, validate storage uploads",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Supabase configuration and database schema",
            "description": "Set up Supabase client configuration and create database tables for courses, lessons, and user data",
            "dependencies": [],
            "details": "Install @supabase/supabase-js package and create lib/supabase.ts configuration file. Design database schema with courses table (id, title, description, slug, status, created_at, user_id), lessons table (id, course_id, title, content, objectives, order_index), and user authentication setup. Create SQL migrations for table creation with proper relationships and indexes.",
            "status": "done",
            "testStrategy": "Test Supabase connection, verify table creation, test basic CRUD operations on tables"
          },
          {
            "id": 2,
            "title": "Implement anonymous user authentication system",
            "description": "Create auto-authentication for anonymous users during course publishing",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement authentication logic that automatically creates anonymous user sessions when users attempt to publish without being logged in. Use Supabase auth.signInAnonymously() method. Create auth utilities in lib/auth.ts to handle user session management, check authentication status, and provide fallback anonymous authentication. Store user session state in localStorage for persistence.",
            "status": "done",
            "testStrategy": "Test anonymous auth creation, verify session persistence, test auth state checking utilities"
          },
          {
            "id": 3,
            "title": "Create course publishing server action",
            "description": "Implement server action to handle course data submission to Supabase",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "Create app/actions/publish-course.ts server action using 'use server' directive. Implement publishCourse function that accepts course data, generates unique slugs using nanoid or similar, validates input data, and saves to Supabase courses and lessons tables. Handle course status updates (draft -> published). Implement upsert logic to handle both new courses and updates to existing courses. Include proper error handling and validation.",
            "status": "done",
            "testStrategy": "Test server action with valid/invalid data, verify slug generation uniqueness, test upsert logic for new and existing courses"
          },
          {
            "id": 4,
            "title": "Implement file upload system for Supabase Storage",
            "description": "Create file upload functionality for course materials and images to Supabase Storage buckets",
            "dependencies": [
              "8.1"
            ],
            "details": "Set up Supabase Storage buckets for course files and images. Create upload utilities in lib/storage.ts to handle file uploads with proper naming conventions (course-id/filename). Implement image optimization and resizing for web delivery. Add file validation (size limits, file types). Create storage bucket policies for public read access and authenticated write access. Handle file path generation and URL retrieval.",
            "status": "done",
            "testStrategy": "Test file uploads with various formats, verify storage bucket permissions, test file size limits and validation"
          },
          {
            "id": 5,
            "title": "Integrate publishing functionality into lessons page",
            "description": "Update lessons page to use the new publishing system and connect to Supabase backend",
            "dependencies": [
              "8.3",
              "8.4"
            ],
            "details": "Modify app/lessons/page.tsx to replace localStorage publishing with Supabase server action. Update handlePublish function to call the publishCourse server action, handle loading states during publish, display success/error messages using toast notifications. Implement proper error handling and rollback mechanisms for failed publishes. Add publish status indicators and progress tracking. Ensure backwards compatibility with existing localStorage data during transition.",
            "status": "done",
            "testStrategy": "Test complete publish flow from lessons page, verify error handling, test loading states and user feedback, validate data persistence in Supabase"
          }
        ]
      },
      {
        "id": 9,
        "title": "Create Course Management Pages",
        "description": "Build /courses page for listing user's courses and /courses/[slug] for public viewing",
        "details": "Create app/courses/page.tsx with Drafts/Published tabs showing user's courses with filters by status. Implement course actions: Open, Publish/Unpublish, Delete with proper confirmations. Create app/courses/[slug]/page.tsx for read-only public course viewing. Add course metadata display (created/updated dates, lesson count). Implement proper RLS queries to show only user's courses in management view.",
        "testStrategy": "Test course listing with proper filtering, verify public course viewing works, test course actions (publish/unpublish/delete), validate RLS security",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create course management page layout and navigation",
            "description": "Create app/courses/page.tsx with header navigation, tabs for Drafts/Published courses, and basic page structure",
            "dependencies": [],
            "details": "Create the main courses page with header containing Back to Upload button, page title 'My Courses', and tab navigation between 'Drafts' and 'Published' courses. Use existing UI components (Card, Button, Tabs) and follow design patterns from existing pages. Include responsive layout with max-width container and proper spacing.",
            "status": "done",
            "testStrategy": "Test page loads correctly, tab navigation works, responsive layout on different screen sizes"
          },
          {
            "id": 2,
            "title": "Implement course listing with localStorage integration",
            "description": "Add course data fetching from localStorage and display course cards with metadata",
            "dependencies": [
              "9.1"
            ],
            "details": "Read course data from localStorage (courseData and publishedCourse keys), filter courses by status based on active tab. Display course cards showing title, description, creation date, lesson count, and publish status. Use existing Card component styling with proper truncation for long text and consistent spacing.",
            "status": "done",
            "testStrategy": "Test with sample course data, verify filtering works correctly, test with empty states"
          },
          {
            "id": 3,
            "title": "Add course action buttons and confirmation dialogs",
            "description": "Implement Open, Publish/Unpublish, and Delete actions with proper confirmation dialogs",
            "dependencies": [
              "9.2"
            ],
            "details": "Add action buttons to each course card: Open (navigate to /lessons), Publish/Unpublish (toggle status and move between tabs), Delete (with confirmation dialog). Use existing Dialog components, Button styling with rounded-[30px] class, and proper state management for confirmation flows. Handle localStorage updates for course status changes.",
            "status": "done",
            "testStrategy": "Test all actions work correctly, confirmation dialogs appear, localStorage updates properly, navigation works"
          },
          {
            "id": 4,
            "title": "Create public course viewing page with slug routing",
            "description": "Build app/courses/[slug]/page.tsx for read-only public course viewing",
            "dependencies": [
              "9.2"
            ],
            "details": "Create dynamic route page that accepts course slug parameter, fetch course data from localStorage using publishedCourse key or course ID. Display course in read-only format similar to existing /course page but without edit capabilities. Include course metadata (created date, lesson count) and navigation between lessons. Handle course not found states gracefully.",
            "status": "done",
            "testStrategy": "Test with valid course slugs, handle invalid slugs gracefully, verify read-only functionality, test lesson navigation"
          },
          {
            "id": 5,
            "title": "Add course metadata display and filtering options",
            "description": "Enhance course cards with detailed metadata and implement status filtering",
            "dependencies": [
              "9.3",
              "9.4"
            ],
            "details": "Add course metadata display including created/updated timestamps, lesson count, and status badges. Implement filtering options for course status (all, draft, published) with clear visual indicators. Format dates using appropriate date formatting, add loading states for data fetching, and ensure proper accessibility with screen reader support.",
            "status": "done",
            "testStrategy": "Test metadata displays correctly, filtering works as expected, verify accessibility features, test with various course states"
          }
        ]
      },
      {
        "id": 10,
        "title": "Update Upload Page for Multi-Format Support",
        "description": "Enhance upload interface to accept all supported file formats with improved file queue",
        "details": "Update app/page.tsx file input accept attribute to include DOCX, MD, TXT, RTF, HTML, PNG, JPG, WebP. Enhance file queue display with MIME type icons and better file information. Update drag-and-drop handling for multiple formats. Add file type validation on frontend before upload. Update processing messages for multi-format handling. Redirect to /outline instead of /lessons after processing.",
        "testStrategy": "Test file uploads with all supported formats, verify file queue displays correctly, test drag-and-drop with mixed file types, validate proper redirects",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update file input accept attribute for all supported formats",
            "description": "Modify the file input accept attribute in app/page.tsx to support DOCX, MD, TXT, RTF, HTML, PNG, JPG, WebP formats in addition to PDF",
            "dependencies": [],
            "details": "Update the file input accept attribute from '.pdf' to include all supported formats: '.pdf,.docx,.md,.txt,.rtf,.html,.png,.jpg,.jpeg,.webp'. This change should be applied to both the hidden file input element and any file selection validation logic.",
            "status": "done",
            "testStrategy": "Verify file input dialog shows all supported file types when opened, test that users can select files of each supported format"
          },
          {
            "id": 2,
            "title": "Add MIME type validation for multi-format support",
            "description": "Update file validation logic in handleDrop and handleFileSelect functions to accept all supported MIME types instead of just PDF",
            "dependencies": [
              "10.1"
            ],
            "details": "Replace the hardcoded 'application/pdf' MIME type checks with a comprehensive list including: 'application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'text/markdown', 'text/plain', 'application/rtf', 'text/html', 'image/png', 'image/jpeg', 'image/webp'. Create a utility function to validate supported file types.",
            "status": "done",
            "testStrategy": "Test drag-and-drop with each supported file format, verify unsupported file types are rejected, test mixed file type uploads"
          },
          {
            "id": 3,
            "title": "Enhance file queue display with MIME type icons",
            "description": "Update the file list display to show appropriate icons based on file MIME type and improve file information presentation",
            "dependencies": [
              "10.2"
            ],
            "details": "Replace the generic FileText icon with conditional icons based on file type (e.g., Image icon for PNG/JPG/WebP, FileText for documents, Code icon for HTML/MD). Add MIME type display alongside file size. Import additional icons from lucide-react like Image, Code, File icons. Update the file display component to show file type-specific information.",
            "status": "done",
            "testStrategy": "Verify correct icons display for each file type, test file information accuracy, ensure responsive layout with different file types"
          },
          {
            "id": 4,
            "title": "Update processing messages for multi-format handling",
            "description": "Modify processing progress messages to reflect multi-format file processing instead of PDF-specific messaging",
            "dependencies": [
              "10.3"
            ],
            "details": "Update Russian processing messages in the useEffect hook to be format-agnostic: replace 'Чтение PDF-файлов...' with 'Обработка файлов...', update other messages to reflect general document processing. Update the file count display logic to handle mixed file types appropriately. Ensure all user-facing text reflects multi-format support.",
            "status": "done",
            "testStrategy": "Test processing flow with different file types, verify appropriate messages display, test with mixed file uploads to ensure correct file count and messaging"
          },
          {
            "id": 5,
            "title": "Update redirect destination from lessons to outline page",
            "description": "Change the post-processing redirect from /lessons to /outline page to align with new course creation workflow",
            "dependencies": [
              "10.4"
            ],
            "details": "Update the router.push('/lessons') call in the handleCreateCourse function to router.push('/outline'). This change aligns with the new workflow where users first review and edit the course outline before accessing individual lessons. Ensure the courseData is still properly stored in localStorage for the outline page to consume.",
            "status": "done",
            "testStrategy": "Test successful course creation redirects to outline page, verify courseData is accessible on outline page, test the complete upload-to-outline workflow"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-04T13:37:34.249Z",
      "updated": "2025-10-06T18:36:04.094Z",
      "description": "Tasks for master context"
    }
  },
  "database": {
    "tasks": [
      {
        "id": 1,
        "title": "Добавить SSR-клиент Supabase для серверных компонентов",
        "description": "Создать lib/supabase/server.ts с функцией createSupabaseServer() используя @supabase/ssr. Это решит проблему анонимных логинов и корректно обработает сессии через cookies.",
        "details": "Файл: lib/supabase/server.ts (новый)\n\nРеализовать:\n- Импортировать cookies из next/headers\n- Импортировать createServerClient из @supabase/ssr\n- Экспортировать функцию createSupabaseServer()\n- Настроить обработчики cookies: get, set, remove\n- Использовать env переменные NEXT_PUBLIC_SUPABASE_URL и NEXT_PUBLIC_SUPABASE_ANON_KEY\n\nЗачем: серверные actions/страницы корректно увидят сессию пользователя (куки/JWT). Это снимет проблему «падают анонимные логины» и позволит фильтровать записи по auth.uid() без костылей.",
        "testStrategy": "Проверить что createSupabaseServer() корректно возвращает клиента с auth сессией в server components",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Создать server actions для работы с курсами из БД",
        "description": "Создать app/actions/courses.ts с полным набором server actions для CRUD операций над курсами и уроками через Supabase БД.",
        "details": "Файл: app/actions/courses.ts (новый, use server)\n\nРеализовать функции:\n1. createCourseFromPayload(payload) — создать курс + уроки (для автосохранения после генерации)\n2. getMyCourses() — список курсов пользователя (для «Мои курсы»)\n3. getCourse(id) — курс с уроками (для редактора)\n4. updateCourse(id, patch) — обновить заголовок/описание/статус\n5. updateLesson(id, patch) — правка урока\n6. reorderLessons(courseId, orderedIds) — смена порядка\n7. deleteCourse(id) — удаление курса каскадом\n\nИспользовать:\n- createSupabaseServer() для всех операций\n- Таблицы из существующей миграции (courses, lessons, source_files)\n- Фильтрацию по user_id через RLS",
        "testStrategy": "Протестировать каждую функцию: создание курса, получение списка, обновление, удаление. Проверить что RLS корректно работает.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Исправить lesson_id в схеме и publish-course.ts",
        "description": "Убрать поле lesson_id из инсёртов в таблицу lessons, т.к. этого поля нет в текущей миграции. Связь уроков с курсом идет через course_id.",
        "details": "Файлы: app/actions/publish-course.ts и новые server actions\n\nПроблема: В текущей миграции lessons нет столбца lesson_id, но код пытается его вставить.\n\nИсправления:\n1. В publish-course.ts удалить lesson_id из lessonsToInsert\n2. В новых server actions (courses.ts) не использовать lesson_id при вставке\n3. Связь — через lessons.course_id + lessons.id как PK\n4. Если lesson_id нужен для FK в source_files/course_assets — проверить что там правильные FK на lessons.id\n\nКритично для работы publish функции!",
        "testStrategy": "Попробовать опубликовать курс и убедиться что нет ошибок SQL про неизвестный столбец lesson_id",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Обновить страницу «Мои курсы» для загрузки из БД",
        "description": "Переделать app/courses/page.tsx в Server Component, загружать курсы из Supabase через getMyCourses(). Показывать БД курсы и локальные черновики отдельными секциями.",
        "details": "Файл: app/courses/page.tsx (правки)\n\nИзменения:\n1. Сделать страницу Server Component (убрать \"use client\")\n2. В async рендере вызывать getMyCourses() для загрузки курсов из БД\n3. Разделить UI на две секции:\n   - \"Мои курсы (из профиля)\" — данные из БД\n   - \"Локальные черновики\" — из localStorage (клиентская часть)\n4. Показывать статус курса (draft/published)\n5. Ссылки на редактор: /courses/[id] для БД курсов\n\nСохранить существующую функциональность с localStorage для гостей.",
        "testStrategy": "Залогиниться, создать курс, проверить что он отображается в секции из БД. Выйти — локальные черновики остаются.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Создать редактор курса из БД /courses/[id]",
        "description": "Добавить новую страницу app/courses/[id]/page.tsx для редактирования курса загруженного из Supabase. Переиспользовать компоненты из outline/lessons pages.",
        "details": "Файл: app/courses/[id]/page.tsx (новый)\n\nРеализация:\n1. Server Component: загрузить курс через getCourse(id)\n2. Вынести общие компоненты редактора из app/outline/page.tsx и app/lessons/page.tsx\n3. Создать компоненты:\n   - CourseEditor (title, description)\n   - LessonsList (drag-drop reorder)\n   - LessonEditor (content, objectives)\n4. Использовать server actions для сохранения:\n   - updateCourse(id, patch)\n   - updateLesson(id, patch)\n   - reorderLessons(courseId, orderedIds)\n5. Показывать статус сохранения\n6. Кнопка \"Опубликовать\" / \"Снять с публикации\"\n\nИзбегать дублирования кода с существующими редакторами.",
        "testStrategy": "Открыть /courses/[id], отредактировать название, содержание урока, изменить порядок — обновить страницу и проверить что изменения сохранились",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Добавить автосохранение в БД после генерации курса",
        "description": "После успешной генерации курса через /api/process-files автоматически сохранять результат в Supabase для авторизованных пользователей и делать редирект на /courses/[id].",
        "details": "Файл: app/page.tsx (правки в handleProcessFiles)\n\nЛогика:\n1. После успешного ответа от /api/process-files\n2. Проверить useAuth(): если пользователь авторизован (не анонимный)\n   - Вызвать createCourseFromPayload(result)\n   - Получить courseId\n   - Редирект на /courses/[id]\n3. Если гость (анонимный):\n   - Текущий флоу: сохранить в localStorage\n   - Редирект на /outline как сейчас\n   - Показать кнопку \"Сохранить в профиль\" (после логина — вызвать createCourseFromPayload и очистить localStorage)\n\nДополнительно:\n- Показать toast с уведомлением \"Курс сохранен в профиль\"\n- Обработка ошибок при сохранении в БД",
        "testStrategy": "Залогиниться, загрузить PDF, дождаться генерации — проверить редирект на /courses/[id] и наличие курса в БД. Выйти, повторить — проверить сохранение в localStorage.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Обновить публичную страницу по slug для чтения из БД",
        "description": "Переделать app/courses/[slug]/page.tsx чтобы загружать опубликованный курс из Supabase по slug вместо localStorage. Добавить поле slug в таблицу courses если его нет.",
        "details": "Файл: app/courses/[slug]/page.tsx (правки)\n\nИзменения:\n1. Сделать Server Component\n2. Создать server action getPublicCourse(slug) в courses.ts\n3. Загружать курс из БД по slug (только со status = 'published')\n4. Показывать 404 если slug не найден или курс не опубликован\n5. Рендерить публичный вид курса (read-only)\n\nМиграция (если нужно):\n- Проверить наличие поля courses.slug (text unique)\n- Если нет — добавить миграцию или ALTER TABLE\n- При publish в publishCourse() генерировать slug если его нет\n- Slug формат: {title-slug}-{nanoid(8)}\n\nRLS: публичное чтение для published курсов.",
        "testStrategy": "Опубликовать курс, получить slug, открыть /courses/[slug] в инкогнито — должен показать курс. Попробовать несуществующий slug — 404.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-07T18:28:16.707Z",
      "updated": "2025-10-07T19:07:22.912Z",
      "description": "Database and Supabase integration features"
    }
  },
  "two": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement database schema for profiles and roles system",
        "description": "Create profiles table with role column and update RLS policies to support admin role access to all courses",
        "details": "Create new migration file for profiles table with user roles ('user'|'admin'), update existing RLS policies to support admin access to all courses while maintaining owner-only access for regular users. Update course policies to allow admins to view/manage all courses. Add indexes for performance.",
        "testStrategy": "Test admin users can access all courses, regular users only see their own courses, RLS policies work correctly in Supabase dashboard and application",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create profiles table migration with user roles",
            "description": "Create a new migration file to add the profiles table with user_id reference, role column (user/admin enum), and proper indexes",
            "dependencies": [],
            "details": "Create migration file 20250108000000_create_profiles_table.sql that adds a profiles table with: id (uuid primary key), user_id (uuid references auth.users), role (enum type 'user' or 'admin' with default 'user'), created_at and updated_at timestamps. Include foreign key constraint with cascade delete and create index on user_id for performance.",
            "status": "done",
            "testStrategy": "Test migration applies cleanly, profiles table exists with correct schema, foreign key constraints work, indexes are created properly"
          },
          {
            "id": 2,
            "title": "Update courses table RLS policies for admin access",
            "description": "Modify existing RLS policies on courses table to allow admin users to view, update, and delete all courses while preserving owner-only access for regular users",
            "dependencies": [
              1
            ],
            "details": "Update the existing RLS policies in courses table to include admin role checks. Modify 'Users can view own courses', 'Users can update own courses', and 'Users can delete own courses' policies to also allow access when user has admin role in profiles table. Use EXISTS subquery to check if auth.uid() has role='admin' in profiles table.",
            "status": "done",
            "testStrategy": "Test admin users can view/edit/delete any course, regular users still only see their own courses, published courses remain publicly viewable"
          },
          {
            "id": 3,
            "title": "Update lessons table RLS policies for admin access",
            "description": "Modify existing RLS policies on lessons table to allow admin users full access to all lessons while maintaining owner-only access for regular users",
            "dependencies": [
              1
            ],
            "details": "Update lessons table RLS policies to include admin role checks. Modify 'Users can view own lessons', 'Users can insert own lessons', 'Users can update own lessons', and 'Users can delete own lessons' policies to also grant access when user has admin role. Use EXISTS subquery to check profiles table for admin role.",
            "status": "done",
            "testStrategy": "Test admin users can manage lessons from any course, regular users still limited to their own course lessons, published lesson access unchanged"
          },
          {
            "id": 4,
            "title": "Update source_files and course_assets RLS policies for admin access",
            "description": "Modify RLS policies on source_files and course_assets tables to grant admin users full access while preserving owner-only access for regular users",
            "dependencies": [
              1
            ],
            "details": "Update all RLS policies on source_files and course_assets tables to include admin role checks. For each table, modify view, insert, update, and delete policies to also allow access when user has admin role in profiles table. Ensure published course assets remain publicly viewable.",
            "status": "done",
            "testStrategy": "Test admin users can manage source files and assets from any course, regular users still limited to their own courses, public asset access preserved"
          },
          {
            "id": 5,
            "title": "Create helper functions for role checking and admin utilities",
            "description": "Create PostgreSQL functions to simplify role checking in RLS policies and provide utilities for admin operations",
            "dependencies": [
              1
            ],
            "details": "Create function is_admin(user_uuid) that returns boolean by checking if user has admin role in profiles table. Create function get_user_role(user_uuid) that returns the user's role. Add indexes on profiles(role) and profiles(user_id, role) for performance. These functions will be used in RLS policies and can be reused across the application.",
            "status": "done",
            "testStrategy": "Test helper functions return correct values, performance is acceptable with indexes, functions can be used in RLS policy conditions successfully"
          }
        ]
      },
      {
        "id": 2,
        "title": "Add author_tone field to courses schema",
        "description": "Extend courses table with author_tone field and validation columns for tone input during course creation",
        "details": "Add author_tone TEXT column to courses table, add last_validated_at timestamptz and last_validation_severity columns. Update course creation API to accept and validate tone input (max 2000 characters, HTML sanitization). Add database migration and update TypeScript types.",
        "testStrategy": "Test tone field accepts valid input, rejects overly long input, sanitizes HTML, persists correctly in database",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create database migration file for author_tone fields",
            "description": "Create a new Supabase migration file to add author_tone, last_validated_at, and last_validation_severity columns to the courses table",
            "dependencies": [],
            "details": "Create a new migration file in supabase/migrations/ directory following the existing naming pattern (timestamp_description.sql). Add author_tone TEXT column, last_validated_at TIMESTAMPTZ column, and last_validation_severity TEXT column with CHECK constraint for severity values (info, warning, error). Include proper indexing for performance.",
            "status": "done",
            "testStrategy": "Verify migration runs successfully against local Supabase instance and schema matches expected structure"
          },
          {
            "id": 2,
            "title": "Update TypeScript Course interface with new fields",
            "description": "Extend the Course interface in app/actions/courses.ts to include the new author_tone and validation fields",
            "dependencies": [
              1
            ],
            "details": "Add author_tone?: string | null, last_validated_at?: string | null, and last_validation_severity?: string | null to the Course interface. Ensure the fields are optional to maintain backward compatibility with existing data.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation passes and no type errors occur in existing course-related functions"
          },
          {
            "id": 3,
            "title": "Update createCourseFromPayload function to accept author_tone",
            "description": "Modify the course creation function to accept and validate author_tone input parameter",
            "dependencies": [
              2
            ],
            "details": "Add author_tone?: string to the payload parameter type, implement validation for max 2000 characters, add HTML sanitization using a sanitization library (investigate if DOMPurify or similar is needed), and include the field in the database insert operation.",
            "status": "done",
            "testStrategy": "Test that valid tone input is accepted and saved, overly long input is rejected, HTML content is properly sanitized"
          },
          {
            "id": 4,
            "title": "Add HTML sanitization utility and validation logic",
            "description": "Implement HTML sanitization and input validation for the author_tone field",
            "dependencies": [
              3
            ],
            "details": "Create a utility function to sanitize HTML content using a secure library (check if project already uses one or add dependency like DOMPurify). Implement character length validation (max 2000), strip dangerous HTML tags while preserving safe formatting, and ensure XSS protection.",
            "status": "done",
            "testStrategy": "Test sanitization removes script tags and dangerous attributes, preserves safe HTML like <p> and <strong>, validates character count correctly"
          },
          {
            "id": 5,
            "title": "Update updateCourse function to handle author_tone updates",
            "description": "Extend the course update functionality to support modifying the author_tone field with proper validation",
            "dependencies": [
              4
            ],
            "details": "Add author_tone?: string to the patch parameter type in updateCourse function, apply the same validation and sanitization logic as in creation, ensure database update includes the new field, and maintain backward compatibility.",
            "status": "done",
            "testStrategy": "Test that existing course updates work without author_tone, new tone values are properly validated and saved, sanitization is applied during updates"
          }
        ]
      },
      {
        "id": 3,
        "title": "Create sources table for URL ingestion support",
        "description": "Design and implement sources table to track both file uploads and URL sources for course generation",
        "details": "Create sources table with fields: id, course_id, type ('file'|'link'), url, content_type, raw_text, meta jsonb, created_at. Add RLS policies consistent with existing tables. Update existing file upload logic to use this new table structure while maintaining backward compatibility.",
        "testStrategy": "Test sources table creation, RLS policies work, file uploads continue working, can store URL source metadata",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create new migration file for sources table",
            "description": "Create a new SQL migration file to define the sources table schema with all required fields and constraints",
            "dependencies": [],
            "details": "Create new migration file at supabase/migrations/[timestamp]_create_sources_table.sql with table definition including: id (uuid primary key), course_id (foreign key to courses), type (enum 'file'|'link'), url (text nullable), content_type (text), raw_text (text nullable), meta (jsonb), created_at (timestamptz). Add proper foreign key constraints and indexes for performance.",
            "status": "done",
            "testStrategy": "Test migration runs successfully in Supabase, table is created with correct schema, foreign key constraints work properly"
          },
          {
            "id": 2,
            "title": "Add RLS policies for sources table",
            "description": "Implement Row Level Security policies for the sources table following existing patterns from courses and lessons tables",
            "dependencies": [
              1
            ],
            "details": "Add RLS policies to the migration file that mirror the existing patterns: users can view/insert/update/delete sources for their own courses, anyone can view sources for published courses. Use the same auth.uid() checks and course ownership verification as existing tables like source_files and lessons.",
            "status": "done",
            "testStrategy": "Test RLS policies allow proper access controls, users can only access their own course sources, published course sources are publicly readable"
          },
          {
            "id": 3,
            "title": "Update TypeScript interfaces for sources table",
            "description": "Add TypeScript interface for Source model and update existing interfaces to support the new sources table structure",
            "dependencies": [
              1
            ],
            "details": "In app/actions/courses.ts, add new Source interface with fields: id, course_id, type, url, content_type, raw_text, meta, created_at. Update createCourseFromPayload function to accept sources array instead of sourceFiles. Keep SourceFile interface for backward compatibility during transition period.",
            "status": "done",
            "testStrategy": "TypeScript compilation succeeds, interface matches database schema exactly, existing code continues to work"
          },
          {
            "id": 4,
            "title": "Migrate existing source_files data to sources table",
            "description": "Create data migration logic to move existing source_files records to the new sources table with proper type mapping",
            "dependencies": [
              1,
              2
            ],
            "details": "Add data migration section to the SQL migration that inserts existing source_files records into sources table with type='file', url=null, content_type=mime, raw_text=text_content. Map storage_path to meta field as jsonb. Ensure all existing data is preserved during migration and foreign key relationships remain intact.",
            "status": "done",
            "testStrategy": "All existing source_files data successfully migrated to sources table, no data loss, relationships preserved, file upload functionality continues working"
          },
          {
            "id": 5,
            "title": "Update file upload logic to use sources table",
            "description": "Modify existing file upload and course creation logic to insert into sources table instead of source_files table",
            "dependencies": [
              3,
              4
            ],
            "details": "Update createCourseFromPayload function in app/actions/courses.ts to insert file data into sources table with type='file'. Map existing sourceFiles parameter structure to new sources format. Add backward compatibility layer to handle both old and new data structures during transition. Update any other file handling code to use sources table.",
            "status": "done",
            "testStrategy": "File uploads work correctly with new sources table, existing file upload functionality preserved, data stored in correct format with proper type field"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement URL ingestion API endpoint",
        "description": "Create API endpoint for extracting content from URLs with proper validation, robots.txt checking, and content parsing",
        "details": "Implement POST /api/sources/ingest-url endpoint using jsdom + @mozilla/readability for HTML parsing, support for text/html, text/plain, application/pdf. Add robots.txt checking, domain allow/deny lists, rate limiting (30 requests/hour per user), size limits (200KB per URL), timeout handling (15s). Return structured response with title, text, wordCount, sourceUrl, contentType.",
        "testStrategy": "Test valid URLs return parsed content, robots.txt blocking works, rate limits enforced, invalid domains rejected, PDF URLs processed correctly",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up API endpoint structure and request validation",
            "description": "Create the basic API endpoint file structure and implement request validation for URL ingestion including URL format validation, allowed domains checking, and request body schema validation.",
            "dependencies": [],
            "details": "Create app/api/sources/ingest-url/route.ts following the existing API patterns in the codebase. Implement POST handler with request validation using zod schema for URL format checking. Add basic URL validation to ensure proper format and protocol (http/https only). Set up error handling structure consistent with existing API endpoints like process-files.",
            "status": "done",
            "testStrategy": "Test with valid and invalid URLs, malformed requests, missing fields, and verify proper error responses"
          },
          {
            "id": 2,
            "title": "Implement robots.txt checking and domain validation",
            "description": "Add robots.txt checking functionality and domain allow/deny list validation to ensure compliance with website crawling policies and security restrictions.",
            "dependencies": [
              1
            ],
            "details": "Create utility functions to fetch and parse robots.txt files from target domains. Check User-Agent permissions and crawl-delay directives. Implement domain allow/deny list functionality with configurable lists (environment variables or config file). Add timeout handling for robots.txt requests (5s timeout). Create helper functions for domain extraction and validation.",
            "status": "done",
            "testStrategy": "Test robots.txt parsing with various formats, domain filtering with allowed/blocked lists, and timeout scenarios"
          },
          {
            "id": 3,
            "title": "Add rate limiting and security controls",
            "description": "Implement rate limiting (30 requests/hour per user), content size limits (200KB), and request timeout handling (15s) for security and performance protection.",
            "dependencies": [
              1
            ],
            "details": "Implement rate limiting using in-memory store or external storage, tracking requests per user/IP with 30 requests/hour limit. Add content-length checking before downloading full content with 200KB limit. Implement request timeout handling with 15s timeout for URL fetching. Add user authentication integration using existing auth patterns from process-files endpoint.",
            "status": "done",
            "testStrategy": "Test rate limit enforcement, content size rejection, timeout handling, and proper user identification"
          },
          {
            "id": 4,
            "title": "Implement content fetching and parsing with jsdom + readability",
            "description": "Add content fetching functionality supporting text/html, text/plain, and application/pdf content types using jsdom and Mozilla Readability for HTML parsing.",
            "dependencies": [
              2,
              3
            ],
            "details": "Install @mozilla/readability package. Implement content fetching with proper User-Agent headers and content-type checking. For HTML content, use jsdom to create DOM and @mozilla/readability to extract clean content. For plain text, return content directly. For PDF, integrate with existing PDF parsing from lib/parsers/pdf.ts. Add proper error handling for network issues, parsing failures, and unsupported content types.",
            "status": "done",
            "testStrategy": "Test HTML parsing with readability, plain text extraction, PDF processing, and various content types"
          },
          {
            "id": 5,
            "title": "Structure response format and integrate with existing parser system",
            "description": "Create structured response format with title, text, wordCount, sourceUrl, and contentType, integrating with the existing ExtractedFile system from lib/parsers.",
            "dependencies": [
              4
            ],
            "details": "Create response format matching the task requirements with title (extracted from HTML title or filename), text content, wordCount calculation, sourceUrl (original URL), and contentType. Integrate with existing ExtractedFile type from lib/parsers/types.ts to maintain consistency with file processing. Add proper error responses for all failure scenarios. Ensure response format is compatible with existing course generation workflow in process-files endpoint.",
            "status": "done",
            "testStrategy": "Test response structure consistency, word count accuracy, title extraction, and integration with existing course generation system"
          }
        ]
      },
      {
        "id": 5,
        "title": "Add URL input interface to course creation page",
        "description": "Extend main upload page with tabs for Files/Links, URL input field, preview functionality, and source management",
        "details": "Add tabs/toggle to main page for Files vs Links sections. In Links section: URL input field, 'Extract' button, preview cards showing title/domain/excerpt, remove button for each link. Integrate with URL ingestion API, show loading states, handle errors gracefully. Limit to 20 URLs per course generation. Update existing file upload flow to work alongside URL sources.",
        "testStrategy": "Test URL input UI, preview generation, error handling, source removal, limits enforced, both files and URLs can be used together",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tabs navigation component to main upload page",
            "description": "Implement a tabs component with 'Files' and 'Links' sections using Radix UI tabs primitive to provide toggle functionality between file upload and URL input interfaces",
            "dependencies": [],
            "details": "Use the existing Tabs component from /components/ui/tabs.tsx to create a TabsList with two TabsTrigger elements for 'Files' and 'Links'. Style with project's rounded design (rounded-[30px] for primary elements). Position above the existing upload area in app/page.tsx. Set 'Files' as default active tab to maintain existing user experience.",
            "status": "pending",
            "testStrategy": "Test tab switching works correctly, default tab is Files, styling matches existing design system"
          },
          {
            "id": 2,
            "title": "Create URL input interface with Extract button",
            "description": "Build the Links tab content with URL input field, validation, and Extract button for processing web links",
            "dependencies": [
              1
            ],
            "details": "Create a new component for the Links tab content featuring: URL input field with placeholder text, real-time URL validation using browser URL constructor, Extract button that triggers URL processing API call. Use existing Input component from /components/ui/input.tsx and Button component with rounded-[30px] styling. Add appropriate icons from lucide-react (Link, Plus) to match existing file upload interface design.",
            "status": "pending",
            "testStrategy": "Test URL validation works, Extract button is only enabled for valid URLs, error states display correctly"
          },
          {
            "id": 3,
            "title": "Implement URL preview cards with metadata display",
            "description": "Create preview cards showing extracted URL metadata including title, domain, excerpt and remove functionality",
            "dependencies": [
              2
            ],
            "details": "Design and implement URL preview cards using Card component from /components/ui/card.tsx. Display extracted metadata: page title, domain name, content excerpt (truncated to ~150 characters), favicon if available. Include remove button with trash icon from lucide-react. Style cards consistently with existing file preview cards in app/page.tsx (rounded-[30px], bg-muted). Implement loading state while URL metadata is being extracted.",
            "status": "pending",
            "testStrategy": "Test preview cards display correct metadata, remove functionality works, loading states show appropriately"
          },
          {
            "id": 4,
            "title": "Add URL collection state management and 20 URL limit",
            "description": "Implement state management for collected URLs with validation and 20 URL per course limit enforcement",
            "dependencies": [
              3
            ],
            "details": "Add useState for URLs array alongside existing files state in app/page.tsx. Implement addUrl, removeUrl functions similar to existing file management. Add validation to enforce 20 URL maximum limit with user-friendly error messaging using existing error state. Display URL count (e.g., 'Added URLs (5/20)') similar to existing 'Выбранные файлы' section. Ensure URLs persist in component state until course creation.",
            "status": "pending",
            "testStrategy": "Test URL limit enforcement works, URL count displays correctly, state management functions properly"
          },
          {
            "id": 5,
            "title": "Integrate URL processing with existing course creation flow",
            "description": "Modify handleCreateCourse function to include URLs in FormData and update processing logic to handle mixed file and URL sources",
            "dependencies": [
              4
            ],
            "details": "Update handleCreateCourse function in app/page.tsx to append URLs to FormData alongside files. Modify processing stages to account for URL extraction time (add to predicted durations). Update progress tracking to show appropriate messages for URL processing. Ensure existing /api/process-files/route.ts can handle URLs in request. Update course creation button to be enabled when either files OR URLs are present (files.length > 0 || urls.length > 0).",
            "status": "pending",
            "testStrategy": "Test course creation works with URLs only, mixed files and URLs, progress tracking shows URL processing steps"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement course validation system",
        "description": "Create comprehensive course validation with both deterministic checks and optional LLM-based deep validation",
        "details": "Implement POST /api/courses/{id}/validate endpoint with fast/deep modes. Fast validation: structure checks (lessons order, unique titles), outline consistency, link validation (HEAD requests), prerequisites validation, content length checks. Deep validation: LLM analysis of objectives vs content, term definitions, transition smoothness. Create course_validations table to store results. Support streaming progress via SSE for long validations.",
        "testStrategy": "Test fast validation detects structural issues, link validation works, deep validation provides meaningful feedback, results stored correctly, streaming works",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create course_validations table schema migration",
            "description": "Create a new database migration to add course_validations table for storing validation results with proper indexing and foreign key constraints",
            "dependencies": [],
            "details": "Create a new migration file (e.g., 20250108000000_add_course_validations.sql) in supabase/migrations/ that creates the course_validations table with fields: id (uuid, primary key), course_id (uuid, foreign key to courses), validation_type (text: 'fast'|'deep'), status (text: 'pending'|'running'|'completed'|'failed'), results (jsonb for storing validation findings), severity (text: 'info'|'warning'|'error'), started_at, completed_at timestamps, and created_at. Include proper indexes and RLS policies following the existing pattern where users can only access validations for their own courses.",
            "status": "pending",
            "testStrategy": "Test migration applies correctly, table created with proper constraints, RLS policies work, indexes exist"
          },
          {
            "id": 2,
            "title": "Implement fast validation logic functions",
            "description": "Create utility functions for performing fast deterministic course validation checks including structure, links, and content validation",
            "dependencies": [
              1
            ],
            "details": "Create lib/validation/fast-validators.ts with functions for: validateCourseStructure (checks lesson order, unique titles, required fields), validateOutlineConsistency (ensures lessons match course description/objectives), validateLinks (performs HEAD requests to external URLs with timeout), validatePrerequisites (checks dependency chains), validateContentLength (ensures lessons meet minimum/maximum word counts). Each function should return a structured result with severity level, message, and affected lesson IDs. Include proper error handling and timeout mechanisms.",
            "status": "pending",
            "testStrategy": "Unit tests for each validator function, test edge cases like broken links, missing content, circular dependencies"
          },
          {
            "id": 3,
            "title": "Implement LLM-based deep validation system",
            "description": "Create AI-powered validation functions that analyze course content quality, consistency, and educational effectiveness using structured prompts",
            "dependencies": [
              2
            ],
            "details": "Create lib/validation/deep-validators.ts with functions for: validateObjectivesAlignment (checks if lesson content matches stated objectives), validateTermDefinitions (ensures consistent terminology across lessons), validateTransitionSmoothness (analyzes logical flow between lessons), validateEducationalQuality (assesses content depth and clarity). Use the existing OpenAI/Anthropic integration pattern from process-files route. Create structured prompts that return JSON validation results with specific feedback. Include retry logic and fallback mechanisms for API failures.",
            "status": "pending",
            "testStrategy": "Test LLM validation provides meaningful feedback, handles API errors gracefully, results are consistent and actionable"
          },
          {
            "id": 4,
            "title": "Create course validation API endpoint with streaming",
            "description": "Implement POST /api/courses/{id}/validate endpoint supporting fast/deep validation modes with Server-Sent Events for progress streaming",
            "dependencies": [
              3
            ],
            "details": "Create app/api/courses/[id]/validate/route.ts endpoint that: validates course ownership using ensureAuthServer, accepts mode parameter ('fast'|'deep'), creates validation record in database, runs appropriate validators, streams progress updates via SSE using ReadableStream, stores final results in course_validations table, returns comprehensive validation report. Include proper error handling, timeout management (15 min max), and validation result caching. Follow the existing API patterns from process-files route for model selection and error responses.",
            "status": "pending",
            "testStrategy": "Test both validation modes work, streaming updates arrive correctly, results stored properly, unauthorized access blocked"
          },
          {
            "id": 5,
            "title": "Add validation UI components and integration",
            "description": "Create React components for triggering course validation, displaying progress, and showing validation results in the course editor interface",
            "dependencies": [
              4
            ],
            "details": "Create components/course-validation/ with: ValidationTrigger (button component with mode selection), ValidationProgress (SSE progress display with spinner), ValidationResults (formatted display of validation findings with severity indicators and actionable suggestions). Integrate these components into the course editor (app/lessons/page.tsx) with proper state management using React hooks. Include loading states, error handling, and result persistence. Style using existing Tailwind patterns and Radix UI components following the codebase conventions.",
            "status": "pending",
            "testStrategy": "Test validation UI triggers correctly, progress updates display properly, results are readable and actionable, error states handled"
          }
        ]
      },
      {
        "id": 7,
        "title": "Add validation UI to courses interface",
        "description": "Create validation interface with progress tracking, detailed reports, and validation history",
        "details": "Add 'Validate Course' button to course page and courses list. Create validation dialog with fast/deep mode selection. Show real-time progress during validation with streaming logs. Display structured validation report with severity levels (ok/warning/error), filterable checks table, quick links to problematic lessons. Add validation badges to course cards showing last validation status and date.",
        "testStrategy": "Test validation UI triggers correctly, progress updates in real-time, reports are readable and actionable, navigation to problem areas works",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create validate course button component",
            "description": "Add 'Validate Course' button to both individual course pages and course cards in the courses list",
            "dependencies": [],
            "details": "Create a reusable ValidateButton component that triggers validation for a course. Should integrate with existing UI patterns - rounded buttons (30px for primary, 25px for secondary). Add to CoursesList.tsx course cards and to course/page.tsx header. Pass course ID/slug as prop. Include loading state and appropriate icons (CheckCircle, AlertTriangle, etc.).",
            "status": "pending",
            "testStrategy": "Test button appears in both locations, handles loading states correctly, passes course data properly"
          },
          {
            "id": 2,
            "title": "Implement validation dialog with mode selection",
            "description": "Create validation dialog component with fast/deep mode selection and start validation functionality",
            "dependencies": [
              1
            ],
            "details": "Build ValidationDialog component using existing Dialog UI pattern from components/ui/dialog.tsx. Include radio buttons or toggle for fast vs deep validation modes. Add descriptive text explaining the difference (fast: structure/links, deep: LLM analysis). Include start validation button and cancel option. Should match existing dialog styling from course/page.tsx edit modal.",
            "status": "pending",
            "testStrategy": "Test dialog opens from validate button, mode selection works, validation starts correctly, can be cancelled"
          },
          {
            "id": 3,
            "title": "Build real-time progress tracking component",
            "description": "Create progress component that shows real-time validation progress with streaming logs",
            "dependencies": [
              2
            ],
            "details": "Implement ValidationProgress component using existing Progress UI from components/ui/progress.tsx. Show percentage progress bar, current step description, and scrollable log area with streaming updates. Use SSE (Server-Sent Events) to receive progress updates from backend API. Include proper error handling and connection recovery. Style similar to existing progress indicators in app/page.tsx processing flow.",
            "status": "pending",
            "testStrategy": "Test progress updates in real-time, logs stream correctly, handles connection errors gracefully, progress reaches 100%"
          },
          {
            "id": 4,
            "title": "Create validation report display component",
            "description": "Build comprehensive validation report component with severity levels, filtering, and navigation",
            "dependencies": [
              3
            ],
            "details": "Develop ValidationReport component displaying structured validation results. Use Table UI from components/ui/table.tsx for filterable checks table with columns: Check Type, Status (ok/warning/error), Description, Action. Include severity level badges using Badge UI. Add quick navigation links to problematic lessons. Implement filtering by severity level and check type. Style consistent with existing card layouts from CoursesList.tsx.",
            "status": "pending",
            "testStrategy": "Test report displays all validation results, filtering works correctly, navigation links jump to appropriate lessons, badges show correct severity"
          },
          {
            "id": 5,
            "title": "Add validation status badges to course cards",
            "description": "Integrate validation status badges into course cards showing last validation status and date",
            "dependencies": [
              4
            ],
            "details": "Extend CoursesList.tsx course cards to display validation badges. Add validation status (ok/warning/error/never) and last validation date near existing metadata (lessons count, update time). Use Badge UI component with appropriate colors (green/yellow/red/gray). Position near existing Calendar and BookOpen icons. Update Course type to include validation fields: last_validated_at, last_validation_severity. Handle cases where course was never validated.",
            "status": "pending",
            "testStrategy": "Test badges appear on all course cards, show correct status and dates, handle never-validated courses properly, styling integrates well with existing card layout"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement course export functionality",
        "description": "Create export system supporting Markdown and plain text formats in single file or multi-file ZIP packages",
        "details": "Implement GET /api/courses/{id}/export endpoint with format (md|txt) and mode (single|multi) parameters. Single mode: generate one file with YAML frontmatter (for md) containing all lessons. Multi mode: create ZIP with individual lesson files (01-intro.md, etc.) and README. Include course metadata: title, author, level, language, tone, lesson count, validation status. Use jszip for ZIP generation, ensure UTF-8 encoding, escape special characters appropriately.",
        "testStrategy": "Test both formats generate correctly, ZIP files contain proper structure, metadata included, special characters handled, download links work",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install jszip dependency and create export API route structure",
            "description": "Set up the foundation for course export functionality by installing jszip package and creating the API route with proper structure and parameter validation.",
            "dependencies": [],
            "details": "Install jszip package using npm. Create app/api/courses/[id]/export/route.ts file following the existing API patterns from process-files/route.ts. Implement GET handler with courseId parameter extraction, query parameter validation for format (md|txt) and mode (single|multi), and basic response structure. Include proper TypeScript types and error handling following the codebase patterns.",
            "status": "pending",
            "testStrategy": "Test API route responds correctly, validates parameters, rejects invalid format/mode combinations, handles missing courseId properly"
          },
          {
            "id": 2,
            "title": "Implement course data retrieval and validation",
            "description": "Create functionality to fetch course data with lessons and validate user permissions using existing course actions patterns.",
            "dependencies": [
              1
            ],
            "details": "Use the existing getCourse function from app/actions/courses.ts to retrieve course data with lessons. Implement proper authentication using ensureAuthServer() and verify user ownership or course publication status. Add validation to ensure course exists and has lessons to export. Handle edge cases like empty courses or missing data following the established error handling patterns.",
            "status": "pending",
            "testStrategy": "Test course retrieval works for valid IDs, rejects unauthorized access, handles non-existent courses, validates lesson data exists"
          },
          {
            "id": 3,
            "title": "Create markdown and text formatting functions",
            "description": "Implement text formatting utilities to convert course and lesson data into markdown and plain text formats with proper metadata inclusion.",
            "dependencies": [
              2
            ],
            "details": "Create formatAsMarkdown() and formatAsText() functions that convert CourseWithLessons data into properly formatted strings. For markdown: include YAML frontmatter with course metadata (title, author, level, language, tone, lesson count, validation status), format lessons with proper headers and structure. For text: create clean plain text version without markdown syntax. Handle special characters escaping and UTF-8 encoding properly.",
            "status": "pending",
            "testStrategy": "Test both formats generate correctly structured output, metadata included properly, special characters escaped, UTF-8 encoding preserved"
          },
          {
            "id": 4,
            "title": "Implement single file export functionality",
            "description": "Create single file export mode that generates one comprehensive file containing all course content with proper headers and formatting.",
            "dependencies": [
              3
            ],
            "details": "Implement single file mode that combines all lessons into one file with course metadata. For markdown: use YAML frontmatter with complete course info followed by all lessons with proper numbering (01-intro, 02-lesson-name, etc.). For text: create structured plain text with clear section separators. Generate appropriate filename based on course title and format. Set proper content-type headers and handle file download response.",
            "status": "pending",
            "testStrategy": "Test single file contains all lessons, proper metadata, correct filename generation, download headers set correctly"
          },
          {
            "id": 5,
            "title": "Implement multi-file ZIP export functionality",
            "description": "Create ZIP export mode that packages individual lesson files with README using jszip library and proper file structure.",
            "dependencies": [
              3
            ],
            "details": "Use jszip to create ZIP packages containing individual lesson files (01-intro.md, 02-advanced-concepts.md, etc.) and a README file with course metadata. Generate proper filenames from lesson titles (slugified), ensure each file has appropriate content headers. Create README with course overview and lesson index. Handle ZIP generation, compression, and binary response with proper content-type headers. Ensure UTF-8 encoding throughout the ZIP creation process.",
            "status": "pending",
            "testStrategy": "Test ZIP files contain proper structure, individual lesson files formatted correctly, README includes metadata, filenames properly slugified, UTF-8 encoding maintained"
          }
        ]
      },
      {
        "id": 9,
        "title": "Add export UI and download interface",
        "description": "Create export menu in course interface with format/mode selection and download management",
        "details": "Add Export menu to course page with dropdown for format (Markdown/Plain Text) and mode (Single File/Multiple Files) selection. Show export progress indicator, generate download links, handle large files appropriately. Provide clear descriptions of each export option. Integrate with course actions menu alongside existing course management features.",
        "testStrategy": "Test export options work correctly, downloads trigger properly, progress indicators show, different formats produce expected results",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create export dropdown menu component",
            "description": "Build an export dropdown menu with format and mode selection options integrated into the course page interface",
            "dependencies": [],
            "details": "Create a reusable export dropdown component that includes format selection (Markdown/Plain Text) and mode selection (Single File/Multiple Files). Use the existing DropdownMenu UI component from @/components/ui/dropdown-menu and integrate it into the course page header alongside existing course management buttons. Include clear descriptions for each export option to help users understand the differences.",
            "status": "pending",
            "testStrategy": "Test dropdown opens correctly, format and mode selections work, descriptions are clear and helpful, integration with course interface is seamless"
          },
          {
            "id": 2,
            "title": "Add export progress indicator with download management",
            "description": "Implement progress tracking and visual feedback during export operations with download status management",
            "dependencies": [
              1
            ],
            "details": "Create an export progress component using the existing Progress UI component and CircularProgress from @/components/ui/loading-spinner. Show export progress during file generation, handle different states (preparing, generating, ready), and display appropriate loading indicators. Include cancel functionality and error handling with user-friendly messages.",
            "status": "pending",
            "testStrategy": "Test progress indicators show correctly during export, different states are visually distinct, cancel functionality works, error states display appropriate messages"
          },
          {
            "id": 3,
            "title": "Implement export state management",
            "description": "Create state management for export operations including format/mode selection and download tracking",
            "dependencies": [],
            "details": "Add React state hooks to manage export configuration (format: 'md'|'txt', mode: 'single'|'multi'), export progress (idle, preparing, generating, ready, error), and download status. Integrate with existing courseData state management patterns used in the course page. Include persistence of user export preferences in localStorage if needed.",
            "status": "pending",
            "testStrategy": "Test state updates correctly when selections change, export progress states transition properly, download status is tracked accurately, user preferences persist across sessions"
          },
          {
            "id": 4,
            "title": "Connect export UI to backend API",
            "description": "Integrate export interface with the existing course export API endpoint to trigger downloads",
            "dependencies": [
              2,
              3
            ],
            "details": "Connect the export UI to the GET /api/courses/{id}/export endpoint with proper parameter passing (format and mode). Handle API responses for download links, implement proper error handling for failed exports, and manage file download triggering. Use the existing courseData structure to get course ID and handle large file downloads appropriately.",
            "status": "pending",
            "testStrategy": "Test API calls are made with correct parameters, download links are generated properly, error responses are handled gracefully, large files download without issues"
          },
          {
            "id": 5,
            "title": "Integrate export menu into course actions",
            "description": "Place export functionality in the course page header alongside existing course management features",
            "dependencies": [
              1,
              4
            ],
            "details": "Integrate the export dropdown into the course page header (app/course/page.tsx) next to the existing 'Редактировать' button. Follow the established design patterns with rounded-[30px] button styling and proper spacing. Ensure the export menu fits naturally with the existing course interface layout and maintains consistent visual hierarchy.",
            "status": "pending",
            "testStrategy": "Test export menu appears in correct location, maintains design consistency with existing buttons, responsive layout works on different screen sizes, no visual conflicts with existing elements"
          }
        ]
      },
      {
        "id": 10,
        "title": "Enhance admin role functionality and course management",
        "description": "Implement admin-specific features for viewing and managing all courses with enhanced filtering and search",
        "details": "Update /courses page to show all courses for admin users with additional filters (Author, Status, Last Validation, Has Warnings). Add admin-specific actions (Validate, Export, Open) in course list. Implement search functionality across all courses. Ensure UI clearly indicates admin mode vs regular user mode. Add course ownership information in admin view. Maintain existing functionality for regular users unchanged.",
        "testStrategy": "Test admin sees all courses, filters work correctly, search functions properly, regular users still see only their courses, admin actions work on any course",
        "priority": "high",
        "dependencies": [
          1,
          7,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add admin role detection to auth-server utilities",
            "description": "Extend auth-server utilities to detect admin users from Supabase user metadata and provide admin role checking functions",
            "dependencies": [],
            "details": "Add isAdminUser() function to auth-server.ts that checks user_metadata.role === 'admin' or similar field in Supabase user object. This will be used throughout admin functionality to determine permissions. Also add getCurrentUserRole() function that returns user role string.",
            "status": "pending",
            "testStrategy": "Test that admin users are correctly identified, regular users return false, and functions work with both authenticated and anonymous users"
          },
          {
            "id": 2,
            "title": "Create admin-aware course fetching functions",
            "description": "Update getMyCourses() in actions/courses.ts to support admin mode that returns all courses with author information",
            "dependencies": [
              1
            ],
            "details": "Modify getMyCourses() to accept optional isAdmin parameter. When true, fetch ALL courses from database with additional fields like author name/email joined from auth.users. Add author information to Course interface. Regular users still see only their own + published courses.",
            "status": "pending",
            "testStrategy": "Test admin sees all courses with author info, regular users see only their courses, course data includes owner information for admin view"
          },
          {
            "id": 3,
            "title": "Implement admin search and filtering functionality",
            "description": "Add search input and advanced filters (Author, Status, Last Validation, Has Warnings) to courses page for admin users",
            "dependencies": [
              2
            ],
            "details": "Create AdminCoursesFilter component with search input for title/description, dropdown filters for Author, Status (draft/published), validation status. Add debounced search functionality. Filter courses client-side initially, with option to move to server-side for large datasets.",
            "status": "pending",
            "testStrategy": "Test search works across all courses, filters combine correctly, UI updates responsively, filters persist during session"
          },
          {
            "id": 4,
            "title": "Update CoursesList component for admin mode",
            "description": "Enhance CoursesList to show admin-specific information and actions when user is admin",
            "dependencies": [
              1,
              2
            ],
            "details": "Add admin mode prop to CoursesList. When admin: show author name in course cards, add 'Admin View' indicator in header, add admin actions (Validate, Export, Open) to each course card. Display course ownership clearly. Maintain all existing functionality for regular users unchanged.",
            "status": "pending",
            "testStrategy": "Test admin sees author info and admin actions, regular users see unchanged interface, all existing functionality still works"
          },
          {
            "id": 5,
            "title": "Implement admin course actions (Validate, Export, Open)",
            "description": "Add admin-specific action buttons and handlers for validating, exporting, and opening any course",
            "dependencies": [
              4
            ],
            "details": "Add three admin action buttons to each course card: Validate (triggers validation API), Export (downloads course), Open (navigates to course view/edit). These actions work on any course regardless of ownership. Handle permissions server-side to ensure only admins can perform these actions.",
            "status": "pending",
            "testStrategy": "Test admin can validate/export/open any course, actions are hidden from regular users, server-side permission checks prevent unauthorized access"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-08T19:53:58.056Z",
      "updated": "2025-10-09T08:48:12.599Z",
      "description": "Tasks for two context"
    }
  }
}